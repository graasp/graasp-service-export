/* eslint no-param-reassign: ["error", { "props": false }] */
/* This function is executed inside page.evaluate and 
thus doesn't have access to external resources 
but has access to the DOM */

// sectionNumber exists if the cover generated is for a subspace
const coverImage = (
  { background, title, sectionNumber, metadata },
  COVER_PROPERTIES
) => {
  const prepareInfoTexts = ({ username, date }) => {
    const defaultStyle = ``;
    const italicStyle = `italic`;

    const lines = [];

    // username
    lines.push({ text: username, style: italicStyle });

    // generated by
    // @TODO change depending on language
    lines.push({ text: 'Generated by Graasp', style: defaultStyle });

    // date
    // @TODO change depending on language
    lines.push({ text: date, style: defaultStyle });

    return lines;
  };

  const writeSecondaryTitle = (
    context,
    heightPadding,
    text,
    {
      FONT,
      MARGIN_LEFT,
      IMAGE_MARGIN,
      IMAGE_HEIGHT,
      LINE_SPACING,
      SECONDARY_TITLE_FONT_SIZE,
    }
  ) => {
    context.font = `${SECONDARY_TITLE_FONT_SIZE}px ${FONT}`;
    const y =
      IMAGE_MARGIN +
      heightPadding +
      IMAGE_HEIGHT +
      SECONDARY_TITLE_FONT_SIZE +
      LINE_SPACING;
    context.fillText(text, MARGIN_LEFT, y);
  };

  const writeMetadata = (
    context,
    heightPadding,
    data,
    { FONT, MARGIN_LEFT, FONT_SIZE, IMAGE_MARGIN, IMAGE_HEIGHT, LINE_SPACING }
  ) => {
    const lines = prepareInfoTexts(data);
    lines.forEach((line, index) => {
      context.font = `${line.style} ${FONT_SIZE}px ${FONT}`;
      const y =
        IMAGE_MARGIN +
        heightPadding +
        IMAGE_HEIGHT +
        (index + 1) * (FONT_SIZE + LINE_SPACING);
      context.fillText(line.text, MARGIN_LEFT, y);
    });
  };

  const {
    BACKGROUND_COLOR,
    FONT,
    FONT_COLOR,
    MARGIN_LEFT,
    MARGIN_TOP,
    LINE_SPACING,
    TITLE_FONT_SIZE,
    TITLE_MARGIN,
  } = COVER_PROPERTIES;

  /* eslint-disable-next-line no-undef */
  const body = document.querySelector('body');
  body.innerHTML += `<canvas width="600" height="800" ></canvas><img id="coverBackground" src="${background}"/>`;

  /* eslint-disable-next-line no-undef */
  const canvas = document.querySelector('canvas');

  // const canvas = createCanvas(600, 800);
  const context = canvas.getContext('2d');

  // background
  context.fillStyle = BACKGROUND_COLOR;
  context.fillRect(0, 0, canvas.width, canvas.height);

  // ils title
  // @TODO ils title too long
  context.font = `${TITLE_FONT_SIZE}px ${FONT}`;
  context.fillStyle = FONT_COLOR;
  const headerTitle = sectionNumber ? `Section ${sectionNumber}` : title;
  context.fillText(
    headerTitle,
    MARGIN_LEFT,
    MARGIN_TOP + TITLE_MARGIN + TITLE_FONT_SIZE
  );

  const headerHeight =
    MARGIN_TOP + TITLE_FONT_SIZE + 2 * TITLE_MARGIN + LINE_SPACING;
  // ils author
  // if(!sectionNumber) {
  //   headerHeight += authorFontSize;
  //   context.font = `${authorFontSize}px ${FONT}`;
  //   context.fillText(author, MARGIN_LEFT, headerHeight);
  // }

  // ils metadata
  if (sectionNumber) {
    writeSecondaryTitle(context, headerHeight, title, COVER_PROPERTIES);
  } else {
    writeMetadata(context, headerHeight, metadata, COVER_PROPERTIES);
  }

  // Image background
  // this part is not displayed in the cover
  // because it is asynchrone and not fully drawn in the canvas
  // when the image is saved
  //  const imageObj = new Image();

  //  imageObj.onload = () => {
  // let x = 0;
  // let y = 0;
  // let cropScaleX = canvas.width;
  // let cropScaleY = IMAGE_HEIGHT;

  // // const image = document.getElementById('coverBackground');
  // // we crop oversized images
  // if (image.height > IMAGE_HEIGHT && image.width > canvas.width) {
  //   x = image.width / 2 - canvas.width / 2;
  //   y = image.height / 2 - IMAGE_HEIGHT / 2;
  //   cropScaleX = canvas.width;
  //   cropScaleY = IMAGE_HEIGHT;
  // } else {
  //   // If image's aspect ratio is less than canvas's we fit on the longest edge
  //   const imageAspectRatio = image.width / image.height;
  //   const canvasAspectRatio = canvas.width / IMAGE_HEIGHT;

  //   if (imageAspectRatio < canvasAspectRatio) {
  //     cropScaleX = image.width;
  //     cropScaleY = IMAGE_HEIGHT * (image.width / canvas.width);
  //     y = image.height / 2 - cropScaleY / 2;
  //   } else if (imageAspectRatio > canvasAspectRatio) {
  //     cropScaleY = image.height;
  //     cropScaleX = canvas.width * (image.height / IMAGE_HEIGHT);
  //     x = image.width / 2 - cropScaleX / 2;
  //   }
  // }

  // context.drawImage(
  //   image,
  //   x,
  //   y,
  //   cropScaleX,
  //   cropScaleY,
  //   0,
  //   IMAGE_MARGIN + headerHeight, // position in canvas - y
  //   canvas.width,
  //   IMAGE_HEIGHT // size from position
  // );

  // imageObj.crossOrigin = 'anonymous'; //not necessary, if image hosted on same server
  // imageObj.src = background;

  return canvas.toDataURL().replace(/^data:image\/\w+;base64,/, '');
};

export default coverImage;
