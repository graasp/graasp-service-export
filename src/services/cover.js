/* eslint no-param-reassign: ["error", { "props": false }] */
import { createCanvas, loadImage } from 'canvas';
import fs from 'fs';
import dateFormat from 'dateformat';
import RomanNumerals from 'roman-numerals';
import Logger from '../utils/Logger';
import { BACKGROUND_COLOR, FONT, FONT_COLOR } from '../config';

const { toRoman } = RomanNumerals;

const marginLeft = 50;
const marginTop = 100;

// general text properties
const fontSize = 20;
const lineSpacing = 5;

// title properties
const titleFontSize = 60;
const titleMargin = 10;

// secondary title properties
const secondaryTitleFontSize = 40;

// author properties
// const authorFontSize = 20;

// image properties
const imageMargin = 15;
const imageHeight = 350;

const prepareInfoTexts = metadata => {
  const defaultStyle = ``;
  const italicStyle = `italic`;

  const lines = [];

  // username
  lines.push({ text: metadata.username, style: italicStyle });

  // generated by
  // @TODO change depending on language
  lines.push({ text: 'Generated by Graasp', style: defaultStyle });

  // date
  // @TODO change depending on language
  const dateText = dateFormat(metadata.date, 'mmmm d, yyyy');
  lines.push({ text: dateText, style: defaultStyle });

  return lines;
};

const writeSecondaryTitle = (context, heightPadding, title) => {
  context.font = `${secondaryTitleFontSize}px ${FONT}`;
  const y =
    imageMargin +
    heightPadding +
    imageHeight +
    secondaryTitleFontSize +
    lineSpacing;
  context.fillText(title, marginLeft, y);
};

const writeMetadata = (context, heightPadding, metadata) => {
  const lines = prepareInfoTexts(metadata);
  lines.forEach((line, index) => {
    context.font = `${line.style} ${fontSize}px ${FONT}`;
    const y =
      imageMargin +
      heightPadding +
      imageHeight +
      (index + 1) * (fontSize + lineSpacing);
    context.fillText(line.text, marginLeft, y);
  });
};

// sectionNumber exists if the cover generated is for a subspace
const coverImage = async (
  background,
  title,
  author,
  sectionNumber,
  metadata,
  path
) => {
  const canvas = createCanvas(600, 800);
  const context = canvas.getContext('2d');

  // background
  context.fillStyle = BACKGROUND_COLOR;
  context.fillRect(0, 0, canvas.width, canvas.height);

  // ils title
  // @TODO ils title too long
  context.font = `${titleFontSize}px ${FONT}`;
  context.fillStyle = FONT_COLOR;
  const headerTitle = sectionNumber
    ? `Section ${toRoman(sectionNumber)}`
    : title;
  context.fillText(
    headerTitle,
    marginLeft,
    marginTop + titleMargin + titleFontSize
  );

  const headerHeight =
    marginTop + titleFontSize + 2 * titleMargin + lineSpacing;
  // ils author
  // if(!sectionNumber) {
  //   headerHeight += authorFontSize;
  //   context.font = `${authorFontSize}px ${FONT}`;
  //   context.fillText(author, marginLeft, headerHeight);
  // }

  // ils metadata
  if (sectionNumber) {
    writeSecondaryTitle(context, headerHeight, title);
  } else {
    writeMetadata(context, headerHeight, metadata);
  }

  // Image background
  await loadImage(background).then(image => {
    let x = 0;
    let y = 0;
    let cropScaleX = canvas.width;
    let cropScaleY = imageHeight;

    // we crop oversized images
    if (image.height > imageHeight && image.width > canvas.width) {
      x = image.width / 2 - canvas.width / 2;
      y = image.height / 2 - imageHeight / 2;
      cropScaleX = canvas.width;
      cropScaleY = imageHeight;
    } else {
      // If image's aspect ratio is less than canvas's we fit on the longest edge
      const imageAspectRatio = image.width / image.height;
      const canvasAspectRatio = canvas.width / imageHeight;

      if (imageAspectRatio < canvasAspectRatio) {
        cropScaleX = image.width;
        cropScaleY = imageHeight * (image.width / canvas.width);
        y = image.height / 2 - cropScaleY / 2;
      } else if (imageAspectRatio > canvasAspectRatio) {
        cropScaleY = image.height;
        cropScaleX = canvas.width * (image.height / imageHeight);
        x = image.width / 2 - cropScaleX / 2;
      }
    }

    context.drawImage(
      image,
      x,
      y,
      cropScaleX,
      cropScaleY,
      0,
      imageMargin + headerHeight, // position in canvas - y
      canvas.width,
      imageHeight // size from position
    );
    const buf = canvas.toBuffer();
    fs.writeFileSync(path, buf);
    Logger.debug('Cover image saved');
  });
};

export default coverImage;
